#!/bin/sh

SLUGIFY() {
	echo "$(echo $1 \
		| tr '[:lower:]' '[:upper:]' \
		| tr '[:blank:]' '_' \
		| tr '-' '_')"
}

USAGE() {
	echo "Usage: $(basename $0) <project-name>"
}

PROJECT_NAME=$1

[ "${PROJECT_NAME:-z}" = "z" ] && USAGE && exit 1

echo "Creating project: $PROJECT_NAME"

# create root directory
mkdir "$PROJECT_NAME"
cd "$PROJECT_NAME"

# create common directories
mkdir "include" "lib" "obj" "out" "src" "test"

# templating include directory
# templating mbs-prelude.h
cat <<'EOF' >> include/mbs_prelude.h
#ifndef MBS_PRELUDE_H
#define MBS_PRELUDE_H

/* Standard includes */
#include <assert.h>
#include <errno.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdnoreturn.h>
#include <string.h>

/* Wide character support */
#include <locale.h>
#include <wchar.h>
#include <wctype.h>

/* Integral types */
typedef uint32_t b32;

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t   s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef float    f32;
typedef double   f64;

/* String types */
struct str_t {
	char *str; /* null terminated */
	size_t len;
};

/* performs a shallow copy of the given string in "in" to the string in "out"
 * ---
 *  in: a pointer to the original string
 *  out: a pointer to the shallow copy of the original string
 */
extern inline void str_copy(const struct str_t *in, struct str_t *out);

/* attempts to deep copy the given string in "in" to the string in "out"
 * ---
 *  in: a pointer to the original string
 *  out: a pointer to the deep copy of the original string
 */
extern inline b32 try_str_clone(const struct str_t *in, struct str_t *out);

struct wstr_t {
	wchar_t *str; /* null terminated */
	size_t len;
};

/* performs a shallow copy of the given string in "in" to the string in "out"
 * ---
 *  in: a pointer to the original string
 *  out: a pointer to the shallow copy of the original string
 */
extern inline void wstr_copy(const struct wstr_t *in, struct wstr_t *out);

/* attempts to deep copy the given string in "in" to the string in "out"
 * ---
 *  in: a pointer to the original string
 *  out: a pointer to the deep copy of the original string
 */
extern inline b32 try_wstr_clone(const struct wstr_t *in, struct wstr_t *out);

#endif /* MBS_PRELUDE_H */
EOF

# templating <project-name>.h
HEADER_NAME="$(SLUGIFY $PROJECT_NAME)"
cat <<EOF >> include/$PROJECT_NAME.h
#ifndef ${HEADER_NAME}_H
#define ${HEADER_NAME}_H

#include "mbs_prelude.h"

/* $PROJECT_NAME definitions */
int main(int argc, char **argv);

#endif /* ${HEADER_NAME}_H */
EOF

# templating src directory
# templating mbs_prelude.c
cat <<'EOF' > src/mbs_prelude.c
#include "mbs_prelude.h"

inline void str_copy(const struct str_t *in, struct str_t *out) {
	assert(in);
	assert(out);

	out->len = in->len;
	out->str = in->str;
}

inline b32 try_str_clone(const struct str_t *in, struct str_t *out) {
	assert(in);
	assert(out);

	char *buf = (char*)malloc(in->len * sizeof(char));
	if (!buf) return false;

	strncpy(buf, in->str, in->len);

	out->len = in->len;
	out->str = buf;

	return true;
}

inline void wstr_copy(const struct wstr_t *in, struct wstr_t *out) {
	assert(in);
	assert(out);

	out->len = in->len;
	out->str = in->str;
}

inline b32 try_wstr_clone(const struct wstr_t *in, struct wstr_t *out) {
	assert(in);
	assert(out);

	wchar_t *buf = (wchar_t*)malloc(in->len * sizeof(wchar_t));
	if (!buf) return false;

	wcsncpy(buf, in->str, in->len);

	out->len = in->len;
	out->str = buf;

	return true;
}
EOF

# templating main.c
cat <<EOF > src/main.c
#include <stdio.h>

#include "$PROJECT_NAME.h"

int main(int argc, char **argv) {
	printf("Hello, World!\\n");

	return 0;
}
EOF

# template test directory
# template test header
cat <<'EOF' > test/mbs_test.h
#ifndef MBS_TEST_H
#define MBS_TEST_H

#include <assert.h>
#include <stdio.h>

#define TEST_BEGIN() \
	printf("*************** %s ***************\n", __FILE__); \
	int test_result = 0;

#define TEST_END() \
	printf("*************** %s ***************\n", __FILE__); \
	return test_result;

#define PASS() return 1;
#define FAIL() return 0;

#define TEST(test_name) int test_name(void)

#define TEST_RUN(test) \
{ \
	printf("%s: ", #test); \
	if (test()) { \
		printf("OK\n"); \
	} else { \
		printf("FAILED\n"); \
		test_result = 1; \
	} \
}

/* Assertions */
#define ASSERT(condition, message) \
	assert((message, (condition)));

#define ASSERT_NE(condition, message) \
	assert((message, !(condition)));

#endif // MBS_TEST_H
EOF

# template example test file
cat <<'EOF' > test/test_example.c
#include "mbs_test.h"

TEST(test_example) {
	int a = 42;

	ASSERT(a == 42, "a must be equal to 42");
	ASSERT_NE(a == 24, "a cannot be equal to 24");

	// FAIL();

	PASS();
}

// example of including a set of test cases
int main(void) {
	TEST_BEGIN();

	TEST_RUN(test_example);

	TEST_END();
}
EOF

# templating miscellaneous files
# templating build
cat <<'EOF' > build
#!/bin/sh

. "$(dirname $0)/common.sh"

# target toolchain flags
COMMON_CXXFLAGS_EXT=""
COMMON_CPPFLAGS_EXT=""
COMMON_LDDFLAGS_EXT=""

DBG_CXXFLAGS_EXT=""
DBG_CPPFLAGS_EXT=""
DBG_LDDFLAGS_EXT=""

REL_CXXFLAGS_EXT=""
REL_CPPFLAGS_EXT=""
REL_LDDFLAGS_EXT=""

CXXFLAGS_EXT="$COMMON_CXXFLAGS_EXT $(REGIME "CXXFLAGS_EXT")"
CPPFLAGS_EXT="$COMMON_CPPFLAGS_EXT $(REGIME "CPPFLAGS_EXT")"
LDDFLAGS_EXT="$COMMON_LDDFLAGS_EXT $(REGIME "LDDFLAGS_EXT")"

[ $VERBOSE ] && echo "$TARGET CXXFLAGS: $CXXFLAGS_EXT"
[ $VERBOSE ] && echo "$TARGET CPPFLAGS: $CPPFLAGS_EXT"
[ $VERBOSE ] && echo "$TARGET LDDFLAGS: $LDDFLAGS_EXT"

SRCS="$(find "$SRC" -name '*.c' -or -name '*.cpp')"
[ $VERBOSE ] && echo "Sources: $SRCS"

# compilation
if [ $UNITY ]; then
	UNITY_SRC="$(UNITY $SRCS)"

	EXECUTABLE $TARGET "$CXXFLAGS_EXT" "$CPPFLAGS_EXT" "$LDDFLAGS_EXT" "$UNITY_SRC"

	rm "$UNITY_SRC"
else
	OBJECTS "$CXXFLAGS_EXT" "$CPPFLAGS_EXT" $SRCS

	# linking
	OBJS="$(find "$OBJ" -name '*.o')"
	[ $VERBOSE ] && echo "Objects: $OBJS"

	EXECUTABLE $TARGET "$CXXFLAGS_EXT" "$CPPFLAGS_EXT" "$LDDFLAGS_EXT" $OBJS
fi

# testing
TESTS="$(find "$TEST" -name '*.c' -or -name '*.cpp')"
[ $VERBOSE ] && echo "Tests: $TESTS"

TEST "$CXXFLAGS_EXT" "$CPPFLAGS_EXT" "$LDFLAGS_EXT" $TESTS
EOF

# templating clean
cat <<'EOF' > clean
#!/bin/sh

. "$(dirname $0)/common.sh"

if [ $VERBOSE ]; then
	rm -frv $OBJ/* $OUT/*
else
	rm -fr $OBJ/* $OUT/*
fi
EOF

# templating common.sh
cat <<EOF > common.sh
#!/bin/sh

TARGET="$PROJECT_NAME"

EOF

cat <<'EOF' >> common.sh
# project root
PWD="$(dirname $0)"

# project directory structure
SRC="$PWD/src"
INC="$PWD/include"
LIB="$PWD/lib"
TEST="$PWD/test"
OBJ="$PWD/obj"
OUT="$PWD/out"

# toolchain
CXX=g++
LD=g++
AR=ar

# toolchain specific flags
CXX_BIN_FLAGS=""
CXX_SO_FLAGS="-shared"

# global toolchain flags
COMMON_CXXFLAGS="$CFLAGS $CXXFLAGS -Wall -Wextra -Wpedantic"
COMMON_CPPFLAGS="$CPPFLAGS -I$INC"
COMMON_LDDFLAGS="$LDFLAGS -L$LIB -L$OUT"

# Returns the correct set of flags based on the compilation regime
# NOTE: requires that the given regime has compilation flag variables in the
#       form ${REGIME}_FLAG_ROOT (where FLAG_ROOT = CXXFLAGS, LDDFLAGS, etc)
# Requires:
#   $REGIME
# Usage:
#   FLAGS="<common-flags> $(REGIME <flag-root>)"
REGIME() {
	eval "echo \"\$${REGIME}_$1\""
}

DBG_CXXFLAGS="-Og -ggdb"
DBG_CPPFLAGS=""
DBG_LDDFLAGS=""

REL_CXXFLAGS="-O3 -flto"
REL_CPPFLAGS="-DNDEBUG"
REL_LDDFLAGS="-flto"

CXXFLAGS="$COMMON_CXXFLAGS $(REGIME "CXXFLAGS")"
CPPFLAGS="$COMMON_CPPFLAGS $(REGIME "CPPGLAGS")"
LDDFLAGS="$COMMON_LDDFLAGS $(REGIME "LDDFLAGS")"

[ $VERBOSE ] && echo "global CXXFLAGS: $CXXFLAGS"
[ $VERBOSE ] && echo "global CPPFLAGS: $CPPFLAGS"
[ $VERBOSE ] && echo "global LDDFLAGS: $LDDFLAGS"

# Executes the given command, echoing it out if the VERBOSE variable is defined
# Overwrites:
#   __TMP_ERRNO
# Usage:
#   EXEC <command...>
EXEC() {
	__TMP_ERRNO=$?; [ $VERBOSE ] && echo "$@"; ( exit $__TMP_ERRNO ) && $@
}

# Echoes the LDFLAGS for the given library
# Usage:
#   LIB <lib-name> <pkg-config-opts...>
LIB() {
	echo "$(pkg-config --libs $@)"
}

# Echoes the CPPFLAGS for the given library
# Usage:
#   INC <lib-name> <pkg-config-opts...>
INC() {
	echo "$(pkg-config --cflags $@)"
}

# Creates a unity build source file from the given sources
# Overwrites:
#   __TMP_SOURCE
# Usage:
#   UNITY_SOURCE="$(UNITY <sources...>)"
UNITY() {
	__TMP_SOURCE="$(mktemp --suffix=.c)"

	for src in $@; do
		printf "#include \"$(readlink -f $src)\"\n" >> "$__TMP_SOURCE"
	done

	echo "$__TMP_SOURCE"
}

# Builds object files from the given sources
# Requires:
#   CXX CXXFLAGS CPPFLAGS OUT
# Overwrites:
#   __OBJ_CXXFLAGS __OBJ_CPPFLAGS
# Usage:
#   OBJECTS "<obj-cxxflags>" "<obj-cppflags>" <sources...>
OBJECTS() {
	__OBJ_CXXFLAGS="$1"
	__OBJ_CPPFLAGS="$2"
	shift 2
	for src in $@; do
		EXEC mkdir -p "$(dirname $OBJ/$src)"
		EXEC $CXX -o "$OBJ/$src.o" -c "$src" $CXXFLAGS $__OBJ_CXXFLAGS $CPPFLAGS $__OBJ_CPPFLAGS
		[ $? -eq 0 ] && echo "Compiled $src -> $OBJ/$src.o"
	done
}

# Builds an executable from the given sources or objects
# Requires:
#   CXX CXX_BIN_FLAGS CXXFLAGS CPPFLAGS LDFLAGS OUT
# Overwrites:
#   __TGT_NAME __TGT_CXXFLAGS __TGT_CPPFLAGS __TGT_LDFLAGS
# Usage:
#   EXECUTABLE <tgt-name> "<tgt-cxxflags>" "<tgt-cppflags>" "<tgt-ldflags>" <sources...>
EXECUTABLE() {
	__TGT_NAME=$1
	__TGT_CXXFLAGS="$2"
	__TGT_CPPFLAGS="$3"
	__TGT_LDFLAGS="$4"
	shift 4
	EXEC $CXX $CXX_BIN_FLAGS -o "$OUT/$__TGT_NAME" $CXXFLAGS $__TGT_CXXFLAS $CPPFLAGS $__TGT_CPPFLAGS $LDFLAGS $__TGT_LDFLAGS $@
	[ $? -eq 0 ] && echo "Built executable: $OUT/$__TGT_NAME"
}

# Builds a shared library from the given sources or objects
# Requires:
#   CXX CXX_SO_FLAGS CXXFLAGS CPPFLAGS LDFLAGS OUT
# Overwrites:
#   __TGT_NAME __TGT_CXXFLAGS __TGT_CPPFLAGS __TGT_LDFLAGS
# Usage:
#   SHAREDLIB <tgt-name> "<tgt-cxxflags>" "<tgt-cppflags>" "<tgt-ldflags>" <sources...>
SHAREDLIB() {
	__TGT_NAME=lib$1.so
	__TGT_CXXFLAGS="$2"
	__TGT_CPPFLAGS="$3"
	__TGT_LDFLAGS="$4"
	shift 4
	EXEC $CXX $CXX_SO_FLAGS -o "$OUT/$__TGT_NAME" $CXXFLAGS $__TGT_CXXFLAS $CPPFLAGS $__TGT_CPPFLAGS $LDFLAGS $__TGT_LDFLAGS $@
	[ $? -eq 0 ] && echo "Built shared library: $OUT/$__TGT_NAME"
}

# Builds a static library from the given objects
# Requires:
#   AR OUT
# Overwrites:
#   __TGT_NAME
# Usage:
#   STATICLIB <tgt-name> <objects...>
STATICLIB() {
	__TGT_NAME=lib$1.a
	shift 1
	EXEC $AR rcs "$OUT/$__TGT_NAME" $@
	[ $? -eq 0 ] && echo "Built static library: $OUT/$__TGT_NAME"
}

# Runs the given tests
# Requires:
#   CXX CXXFLAGS CPPFLAGS LDFLAGS LIB OUT TEST
# Overwrites:
#   __TEST_CXXFLAGS __TEST_CPPFLAGS __TEST_LDFLAGS __TEST_TMP
# Usage:
#   TEST "<test-cxxflags>" "<test-cppflags>" "<test-ldflags>" <tests...>
TEST() {
	__TEST_CXXFLAGS="$1"
	__TEST_CPPFLAGS="$2"
	__TEST_LDFLAGS="$3"
	shift 3
	__TEST_TMP=0
	for test_src in $@; do
		EXEC mkdir -p "$(dirname $OUT/$test_src.x)"
		EXEC $CXX -o "$OUT/$test_src.x" "$test_src" -Wno-unused-value $CXXFLAGS $__TEST_CXXFLAGS -I$TEST $CPPFLAGS $__TEST_CPPFLAGS $LDFLAGS $__TEST_LDFLAGS && \
			LD_LIBRARY_PATH="$OUT:$LIB:$LD_LIBRARY_PATH" "$OUT/$test_src.x"
		[ $? -ne 0 ] && __TEST_TMP=1
	done
	echo "Ran tests: $([ $__TEST_TMP -eq 0 ] && echo PASS || echo FAIL)"
}
EOF

# templating .gitignore
cat <<'EOF' > .gitignore
obj/
out/
EOF

# initialise git repository
git init

# setting execute permissions
chmod +x build clean

# create wrapper Makefile
cat <<EOF > Makefile
.PHONY: clean debug debug-unity release release-unity run run-unity

run: debug
	./out/$PROJECT_NAME

run-unity: debug-unity
	./out/$PROJECT_NAME

debug: clean
	REGIME=DBG ./build

debug-unity: clean
	REGIME=DBG UNITY=1 ./build

release: clean
	REGIME=REL ./build

release-unity: clean
	REGIME=REL UNITY=1 ./build

clean:
	./clean
EOF

# create initial README.md
cat <<EOF > README.md
# $PROJECT_NAME

EOF

echo "Done!"
