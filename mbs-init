#!/bin/sh

SLUGIFY() {
	echo "$(echo $1 \
		| tr '[:lower:]' '[:upper:]' \
		| tr '[:blank:]' '_' \
		| tr '-' '_')"
}

USAGE() {
	echo "Usage: $(basename $0) <project-name>"
}

PROJECT_NAME=$1

[ "${PROJECT_NAME:-z}" = "z" ] && USAGE && exit 1

echo "Creating project: $PROJECT_NAME"

# create root directory
mkdir "$PROJECT_NAME"
cd "$PROJECT_NAME"

# create common directories
mkdir "include" "lib" "obj" "out" "src" "test"

# templating include directory
# templating <project-name>.h
HEADER_NAME="$(SLUGIFY $PROJECT_NAME)"
cat <<EOF >> include/$PROJECT_NAME.h
#ifndef ${HEADER_NAME}_H
#define ${HEADER_NAME}_H

/* Standard includes */
#include <assert.h>
#include <errno.h>
#include <stdalign.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdnoreturn.h>

/* Wide character support */
#include <locale.h>
#include <wchar.h>
#include <wctype.h>

/* Integral types */
typedef uint32_t b32;

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t   s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef float    f32;
typedef double   f64;

/* String types */
struct str_t {
	char *str;
	size_t len;
};

struct wstr_t {
	wchar_t *str;
	size_t len;
};

/* $PROJECT_NAME definitions */
int main(int argc, char **argv);

#endif /* ${HEADER_NAME}_H */
EOF

# templating src directory
# templating main.c
cat <<EOF > src/main.c
#include <stdio.h>

#include "$PROJECT_NAME.h"

int main(int argc, char **argv) {
	printf("Hello, World!\\n");

	return 0;
}
EOF

# template test directory
# template test header
cat <<'EOF' > test/mbs_test.h
#ifndef MBS_TEST_H
#define MBS_TEST_H

#include <assert.h>
#include <stdio.h>

#define TEST_BEGIN() \
	printf("*************** %s ***************\n", __FILE__); \
	int test_result = 0;

#define TEST_END() \
	printf("*************** %s ***************\n", __FILE__); \
	return test_result;

#define PASS() return 1;
#define FAIL() return 0;

#define TEST(test_name) int test_name(void)

#define TEST_RUN(test) \
{ \
	printf("%s: ", #test); \
	if (test()) { \
		printf("OK\n"); \
	} else { \
		printf("FAILED\n"); \
		test_result = 1; \
	} \
}

/* Assertions */
#define ASSERT(condition, message) \
	assert((message, (condition)));

#define ASSERT_NE(condition, message) \
	assert((message, !(condition)));

#endif // MBS_TEST_H
EOF

# template example test file
cat <<'EOF' > test/test_example.c
#include "mbs_test.h"

TEST(test_example) {
	int a = 42;

	ASSERT(a == 42, "a must be equal to 42");
	ASSERT_NE(a == 24, "a cannot be equal to 24");

	// FAIL();

	PASS();
}

// example of including a set of test cases
int main(void) {
	TEST_BEGIN();

	TEST_RUN(test_example);

	TEST_END();
}
EOF

# templating miscellaneous files
# templating build
cat <<EOF > build
#!/bin/sh

. "\$(dirname \$0)/common.sh"

# target toolchain flags
COMMON_CXXFLAGS_EXT=""
COMMON_CPPFLAGS_EXT=""
COMMON_LDDFLAGS_EXT=""

DBG_CXXFLAGS_EXT=""
DBG_CPPFLAGS_EXT=""
DBG_LDDFLAGS_EXT=""

REL_CXXFLAGS_EXT=""
REL_CPPFLAGS_EXT=""
REL_LDDFLAGS_EXT=""

CXXFLAGS_EXT="\$COMMON_CXXFLAGS_EXT \$(REGIME "\$DBG_CXXFLAGS_EXT" "\$REL_CXXFLAGS_EXT")"
CPPFLAGS_EXT="\$COMMON_CPPFLAGS_EXT \$(REGIME "\$DBG_CPPFLAGS_EXT" "\$REL_CPPFLAGS_EXT")"
LDDFLAGS_EXT="\$COMMON_LDDFLAGS_EXT \$(REGIME "\$DBG_LDDFLAGS_EXT" "\$REL_LDDFLAGS_EXT")"

[ \$VERBOSE ] && echo "$PROJECT_NAME CXXFLAGS: \$CXXFLAGS_EXT"
[ \$VERBOSE ] && echo "$PROJECT_NAME CPPFLAGS: \$CPPFLAGS_EXT"
[ \$VERBOSE ] && echo "$PROJECT_NAME LDDFLAGS: \$LDDFLAGS_EXT"


# compilation
SRCS="\$(find "\$SRC" -name '*.c' -or -name '*.cpp')"
[ \$VERBOSE ] && echo "Sources: \$SRCS"

OBJECTS "\$CXXFLAGS_EXT" "\$CPPFLAGS_EXT" \$SRCS


# linking
OBJS="\$(find "\$OBJ" -name '*.o')"
[ \$VERBOSE ] && echo "Objects: \$OBJS"

EXECUTABLE $PROJECT_NAME "\$CXXFLAGS_EXT" "\$CPPFLAGS_EXT" "\$LDFLAGS_EXT" \$OBJS


# testing
TESTS="\$(find "\$TEST" -name '*.c' -or -name '*.cpp')"
[ \$VERBOSE ] && echo "Tests: \$TESTS"

TEST "\$CXXFLAGS_EXT" "\$CPPFLAGS_EXT" "\$LDFLAGS_EXT" \$TESTS
EOF

# templating clean
cat <<'EOF' > clean
#!/bin/sh

. "$(dirname $0)/common.sh"

if [ $VERBOSE ]; then
	rm -frv $OBJ/* $OUT/*
else
	rm -fr $OBJ/* $OUT/*
fi
EOF

# templating common.sh
cat <<'EOF' > common.sh
#!/bin/sh

# project root
PWD="$(dirname $0)"

# project directory structure
SRC="$PWD/src"
INC="$PWD/include"
LIB="$PWD/lib"
TEST="$PWD/test"
OBJ="$PWD/obj"
OUT="$PWD/out"

# toolchain
CXX=g++
LD=g++
AR=ar

# toolchain specific flags
CXX_BIN_FLAGS=""
CXX_SO_FLAGS="-shared"

# global toolchain flags
COMMON_CXXFLAGS="-Wall -Wextra -Wpedantic"
COMMON_CPPFLAGS="-I$INC"
COMMON_LDDFLAGS="-L$LIB -L$OUT"

# Returns the correct set of flags based on the compilation regime
# NOTE: setting multiple regime variables will result in multiple
#       sets of flags being echoed out
# Requires:
#   $DBG $REL
# Usage:
#   FLAGS="<common-flags> $(REGIME "<debug-flags>" "<release-flags>")"
REGIME() {
	[ $DBG ] && echo "$1"
	[ $REL ] && echo "$2"
}

DBG_CXXFLAGS="-Og -ggdb"
DBG_CPPFLAGS=""
DBG_LDDFLAGS=""

REL_CXXFLAGS="-O3 -flto"
REL_CPPFLAGS="-DNDEBUG"
REL_LDDFLAGS="-flto"

CXXFLAGS="$COMMON_CXXFLAGS $(REGIME "$DBG_CXXFLAGS" "$REL_CXXFLAGS")"
CPPFLAGS="$COMMON_CPPFLAGS $(REGIME "$DBG_CPPGLAGS" "$REL_CPPFLAGS")"
LDDFLAGS="$COMMON_LDDFLAGS $(REGIME "$DBG_LDDFLAGS" "$REL_LDDFLAGS")"

[ $VERBOSE ] && echo "global CXXFLAGS: $CXXFLAGS"
[ $VERBOSE ] && echo "global CPPFLAGS: $CPPFLAGS"
[ $VERBOSE ] && echo "global LDDFLAGS: $LDDFLAGS"

# Executes the given command, echoing it out if the VERBOSE variable is defined
# Overwrites:
#   __TMP_ERRNO
# Usage:
#   EXEC <command...>
EXEC() {
	__TMP_ERRNO=$?; [ $VERBOSE ] && echo "$@"; ( exit $__TMP_ERRNO ) && $@
}

# Echoes the LDFLAGS for the given library
# Usage:
#   LIB <lib-name> <pkg-config-opts...>
LIB() {
	echo "$(pkg-config --libs $@)"
}

# Echoes the CPPFLAGS for the given library
# Usage:
#   INC <lib-name> <pkg-config-opts...>
INC() {
	echo "$(pkg-config --cflags $@)"
}

# Builds object files from the given sources
# Requires:
#   CXX CXXFLAGS CPPFLAGS OUT
# Overwrites:
#   __OBJ_CXXFLAGS __OBJ_CPPFLAGS
# Usage:
#   OBJECTS "<obj-cxxflags>" "<obj-cppflags>" <sources...>
OBJECTS() {
	__OBJ_CXXFLAGS="$1"
	__OBJ_CPPFLAGS="$2"
	shift 2
	for src in $@; do
		EXEC mkdir -p "$(dirname $OBJ/$src)"
		EXEC $CXX -o "$OBJ/$src.o" $CXXFLAGS $__OBJ_CXXFLAGS $CPPFLAGS $__OBJ_CPPFLAGS -c "$src"
		[ $? -eq 0 ] && echo "Compiled $src -> $OBJ/$src.o"
	done
}

# Builds an executable from the given sources or objects
# Requires:
#   CXX CXX_BIN_FLAGS CXXFLAGS CPPFLAGS LDFLAGS OUT
# Overwrites:
#   __TGT_NAME __TGT_CXXFLAGS __TGT_CPPFLAGS __TGT_LDFLAGS
# Usage:
#   EXECUTABLE <tgt-name> "<tgt-cxxflags>" "<tgt-cppflags>" "<tgt-ldflags>" <sources...>
EXECUTABLE() {
	__TGT_NAME=$1
	__TGT_CXXFLAGS="$2"
	__TGT_CPPFLAGS="$3"
	__TGT_LDFLAGS="$4"
	shift 4
	EXEC $CXX $CXX_BIN_FLAGS -o "$OUT/$__TGT_NAME" $CXXFLAGS $__TGT_CXXFLAS $CPPFLAGS $__TGT_CPPFLAGS $LDFLAGS $__TGT_LDFLAGS $@
	[ $? -eq 0 ] && echo "Built executable: $OUT/$__TGT_NAME"
}

# Builds a shared library from the given sources or objects
# Requires:
#   CXX CXX_SO_FLAGS CXXFLAGS CPPFLAGS LDFLAGS OUT
# Overwrites:
#   __TGT_NAME __TGT_CXXFLAGS __TGT_CPPFLAGS __TGT_LDFLAGS
# Usage:
#   SHAREDLIB <tgt-name> "<tgt-cxxflags>" "<tgt-cppflags>" "<tgt-ldflags>" <sources...>
SHAREDLIB() {
	__TGT_NAME=lib$1.so
	__TGT_CXXFLAGS="$2"
	__TGT_CPPFLAGS="$3"
	__TGT_LDFLAGS="$4"
	shift 4
	EXEC $CXX $CXX_SO_FLAGS -o "$OUT/$__TGT_NAME" $CXXFLAGS $__TGT_CXXFLAS $CPPFLAGS $__TGT_CPPFLAGS $LDFLAGS $__TGT_LDFLAGS $@
	[ $? -eq 0 ] && echo "Built shared library: $OUT/$__TGT_NAME"
}

# Builds a static library from the given objects
# Requires:
#   AR OUT
# Overwrites:
#   __TGT_NAME
# Usage:
#   STATICLIB <tgt-name> <objects...>
STATICLIB() {
	__TGT_NAME=lib$1.a
	shift 1
	EXEC $AR rcs "$OUT/$__TGT_NAME" $@
	[ $? -eq 0 ] && echo "Built static library: $OUT/$__TGT_NAME"
}

# Runs the given tests
# Requires:
#   CXX CXXFLAGS CPPFLAGS LDFLAGS LIB OUT TEST
# Overwrites:
#   __TEST_NAME __TEST_CXXFLAGS __TEST_CPPFLAGS __TEST_LDFLAGS __TEST_TMP
# Usage:
#   TEST "<test-cxxflags>" "<test-cppflags>" "<test-ldflags>" <tests...>
TEST() {
	__TEST_CXXFLAGS="$1"
	__TEST_CPPFLAGS="$2"
	__TEST_LDFLAGS="$3"
	shift 3
	__TEST_TMP=0
	for test_src in $@; do
		__TEST_NAME=$test_src.x
		EXEC mkdir -p "$(dirname $OUT/$__TEST_NAME)"
		EXEC $CXX -o "$OUT/$__TEST_NAME" $test_src -Wno-unused-value $CXXFLAGS $__TEST_CXXFLAGS -I$TEST $CPPFLAGS $__TEST_CPPFLAGS $LDFLAGS $__TEST_LDFLAGS && LD_LIBRARY_PATH="$OUT:$LIB:$LD_LIBRARY_PATH" "$OUT/$__TEST_NAME"
		[ $? -ne 0 ] && __TEST_TMP=1
	done
	echo "Ran tests: $([ $__TEST_TMP -eq 0 ] && echo PASS || echo FAIL)"
}
EOF

# templating .gitignore
cat <<'EOF' > .gitignore
obj/
out/
EOF

# initialise git repository
git init

# setting execute permissions
chmod +x build clean

# create wrapper Makefile
cat <<EOF > Makefile
.PHONY: clean debug release run

run: clean debug
	./out/$PROJECT_NAME

debug: clean
	DBG=1 ./build

release: clean
	REL=1 ./build

clean:
	./clean
EOF

# create initial README.md
cat <<EOF > README.md
# $PROJECT_NAME

EOF

echo "Done!"
