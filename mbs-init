#!/bin/sh

SLUGIFY() {
	echo "$(echo $1 \
		| tr '[:lower:]' '[:upper:]' \
		| tr '[:blank:]' '_' \
		| tr '-' '_')"
}

USAGE() {
	echo "Usage: $(basename $0) <project-name>"
}

PROJECT_NAME=$1

[ "${PROJECT_NAME:-z}" = "z" ] && USAGE && exit 1

echo "Creating project: $PROJECT_NAME"

# create root directory
mkdir "$PROJECT_NAME"
cd "$PROJECT_NAME"

# create common directories
mkdir "include" "lib" "obj" "out" "src" "test"

# templating include directory
# templating <project-name>.h
HEADER_NAME="$(SLUGIFY $PROJECT_NAME)"
cat <<EOF >> include/$PROJECT_NAME.h
#ifndef ${HEADER_NAME}_H
#define ${HEADER_NAME}_H

/* Standard includes */
#include <assert.h>
#include <errno.h>
#include <stdalign.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdnoreturn.h>
#include <string.h>

/* Wide character support */
#include <locale.h>
#include <wchar.h>
#include <wctype.h>

/* Macros */
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define ARRLEN(arr) (sizeof(arr) / sizeof(arr[0]))

/* Integral types */
typedef uint32_t b32;

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t   s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef float    f32;
typedef double   f64;

/* String types */
struct str_t {
	char *str;
	size_t len;
};

struct wstr_t {
	wchar_t *str;
	size_t len;
};

#ifndef NDEBUG
	/* prints out the given format string to standard error
	 * ---
	 *  fmt: the format string to print
	 *  ...: the variadic arguments to fprintf
	 */
	#define dbglog(...) fprintf(stderr, __VA_ARGS__)
#else
	/* if NDEBUG is defined, this function will do nothing
	 */
	#define dbglog(...)
#endif

#define errlog(...) fprintf(stderr, __VA_ARGS__)

/* $PROJECT_NAME definitions */
int main(int argc, char **argv);

#endif /* ${HEADER_NAME}_H */
EOF

# templating main.c
cat <<EOF > src/main.c
#include <stdio.h>

#include "$PROJECT_NAME.h"

int main(int argc, char **argv) {
	printf("Hello, World!\\n");

	return 0;
}
EOF

# template test directory
# template test header
cat <<'EOF' > test/mbs_test.h
#ifndef MBS_TEST_H
#define MBS_TEST_H

#include <stdio.h>

#define TEST_BEGIN()								\
	fprintf(stderr, "*************** %s ***************\n", __FILE__);	\
	int __result = 0;

#define TEST_END()								\
	fprintf(stderr, "*************** %s ***************\n", __FILE__);	\
	return __result;

#define PASS() return 1;
#define FAIL() return 0;

#define TEST(test_name, test_body)						\
int test_name(void) {								\
	int __##test_name##_result = 1;						\
										\
	test_body								\
										\
	return __##test_name##_result;						\
}

#define TEST_RUN(test)								\
{										\
	fprintf(stderr, "%s: ", #test);						\
	if (test()) {								\
		fprintf(stderr, "OK\n");					\
	} else {								\
		fprintf(stderr, "FAILED\n");					\
		__result = 1;							\
	}									\
}

/* Assertions */
#define ASSERT(condition, message)						\
if (!(condition)) { fprintf(stderr, (message)); FAIL(); }

#define ASSERT_NE(condition, message)						\
if ((condition)) { fprintf(stderr, (message)); FAIL(); }

#endif /* MBS_TEST_H */
EOF

# template example test file
cat <<'EOF' > test/test_example.c
#include "mbs_test.h"

TEST(test_example, {
	int a = 42;

	ASSERT(a == 42, "a must be equal to 42");
	ASSERT_NE(a == 24, "a cannot be equal to 24");

	// FAIL();

	PASS();
})

// example of including a set of test cases
int main(void) {
	TEST_BEGIN();

	TEST_RUN(test_example);

	TEST_END();
}
EOF

# templating miscellaneous files
# templating common.sh
cat <<EOF > common.sh
#!/bin/sh

TARGET="$PROJECT_NAME"

EOF

cat <<'EOF' >> common.sh
# project root
PWD="$(dirname $0)"

# project directory structure
SRC="$PWD/src"
INC="$PWD/include"
LIB="$PWD/lib"
TEST="$PWD/test"
OBJ="$PWD/obj"
OUT="$PWD/out"

# toolchain
CCX=g++
LD=g++
AR=ar

# toolchain specific flags
CCX_BIN_FLAGS=""
CCX_SO_FLAGS="-shared"

# global toolchain flags
COMMON_CCXFLAGS="$CFLAGS $CCXFLAGS -Wall -Wextra -Wpedantic"
COMMON_CPPFLAGS="$CPPFLAGS -I$INC"
COMMON_LDFLAGS="$LDFLAGS -L$LIB -L$OUT"

# Returns the correct set of flags based on the compilation regime
# NOTE: requires that the given regime has compilation flag variables in the
#       form ${REGIME}_FLAG_ROOT (where FLAG_ROOT = CCXFLAGS, LDFLAGS, etc)
# Requires:
#   $REGIME
# Usage:
#   FLAGS="<common-flags> $(REGIME <flag-root>)"
REGIME() {
	eval "echo \"\$${REGIME}_$1\""
}

DBG_CCXFLAGS="-Og -ggdb"
DBG_CPPFLAGS=""
DBG_LDFLAGS=""

REL_CCXFLAGS="-O3 -flto"
REL_CPPFLAGS="-DNDEBUG"
REL_LDFLAGS="-flto"

CCXFLAGS="$COMMON_CCXFLAGS $(REGIME "CCXFLAGS")"
CPPFLAGS="$COMMON_CPPFLAGS $(REGIME "CPPFLAGS")"
LDFLAGS="$COMMON_LDFLAGS $(REGIME "LDFLAGS")"

[ $VERBOSE ] && echo "global CCXFLAGS: $CCXFLAGS"
[ $VERBOSE ] && echo "global CPPFLAGS: $CPPFLAGS"
[ $VERBOSE ] && echo "global LDFLAGS: $LDFLAGS"

# Logs the given parameters to stderr if the VERBOSE variable is defined
# Usage:
#   LOG <message...>
LOG() {
	[ $VERBOSE ] && printf "%s\n" "$*" >&2
}

# Executes the given command, echoing it out if the VERBOSE variable is defined
# Overwrites:
#   __TMP_ERRNO
# Usage:
#   EXEC <command...>
EXEC() {
	__TMP_ERRNO=$?; [ $VERBOSE ] && LOG $@; ( exit $__TMP_ERRNO ) && $@
}

# Echoes the LDFLAGS for the given library
# Usage:
#   LIB <lib-name> <pkg-config-opts...>
LIB() {
	echo "$(pkg-config --libs $@)"
}

# Echoes the CPPFLAGS for the given library
# Usage:
#   INC <lib-name> <pkg-config-opts...>
INC() {
	echo "$(pkg-config --cflags $@)"
}

# Builds object files from the given sources
# Requires:
#   CCX CCXFLAGS CPPFLAGS OUT
# Overwrites:
#   __OBJ_CCXFLAGS __OBJ_CPPFLAGS
# Usage:
#   OBJECTS "<obj-cxxflags>" "<obj-cppflags>" <sources...>
OBJECTS() {
	__OBJ_CCXFLAGS="$1"
	__OBJ_CPPFLAGS="$2"
	shift 2
	for src in $@; do
		EXEC mkdir -p "$(dirname $OBJ/$src)"
		EXEC $CCX -o "$OBJ/$src.o" -c "$src" $CCXFLAGS $__OBJ_CCXFLAGS $CPPFLAGS $__OBJ_CPPFLAGS
		[ $? -eq 0 ] && LOG "Compiled $src -> $OBJ/$src.o"
		echo "$OBJ/$src.o"
	done
}

# Builds an executable from the given sources or objects
# Requires:
#   CCX CCX_BIN_FLAGS CCXFLAGS CPPFLAGS LDFLAGS OUT
# Overwrites:
#   __TGT_NAME __TGT_CCXFLAGS __TGT_CPPFLAGS __TGT_LDFLAGS
# Usage:
#   EXECUTABLE <tgt-name> "<tgt-cxxflags>" "<tgt-cppflags>" "<tgt-lddflags>" <sources...>
EXECUTABLE() {
	__TGT_NAME=$1
	__TGT_CCXFLAGS="$2"
	__TGT_CPPFLAGS="$3"
	__TGT_LDFLAGS="$4"
	shift 4
	EXEC $CCX $CCX_BIN_FLAGS -o "$OUT/$__TGT_NAME" $CCXFLAGS $__TGT_CCXFLAS $CPPFLAGS $__TGT_CPPFLAGS $LDFLAGS $__TGT_LDFLAGS $@
	[ $? -eq 0 ] && LOG "Built executable: $OUT/$__TGT_NAME"
	echo "$OUT/$__TGT_NAME"
}

# Builds a shared library from the given sources or objects
# Requires:
#   CCX CCX_SO_FLAGS CCXFLAGS CPPFLAGS LDFLAGS OUT
# Overwrites:
#   __TGT_NAME __TGT_CCXFLAGS __TGT_CPPFLAGS __TGT_LDFLAGS
# Usage:
#   SHAREDLIB <tgt-name> "<tgt-cxxflags>" "<tgt-cppflags>" "<tgt-lddflags>" <sources...>
SHAREDLIB() {
	__TGT_NAME=lib$1.so
	__TGT_CCXFLAGS="$2"
	__TGT_CPPFLAGS="$3"
	__TGT_LDFLAGS="$4"
	shift 4
	EXEC $CCX $CCX_SO_FLAGS -o "$OUT/$__TGT_NAME" $CCXFLAGS $__TGT_CCXFLAS $CPPFLAGS $__TGT_CPPFLAGS $LDFLAGS $__TGT_LDFLAGS $@
	[ $? -eq 0 ] && LOG "Built shared library: $OUT/$__TGT_NAME"
	echo "$OUT/$__TGT_NAME"
}

# Builds a static library from the given objects
# Requires:
#   AR OUT
# Overwrites:
#   __TGT_NAME
# Usage:
#   STATICLIB <tgt-name> <objects...>
STATICLIB() {
	__TGT_NAME=lib$1.a
	shift 1
	EXEC $AR rcs "$OUT/$__TGT_NAME" $@
	[ $? -eq 0 ] && LOG "Built static library: $OUT/$__TGT_NAME"
	echo "$OUT/$__TGT_NAME"
}

# Runs the given tests
# Requires:
#   CCX CCXFLAGS CPPFLAGS LDFLAGS LIB OUT TEST
# Overwrites:
#   __TEST_CCXFLAGS __TEST_CPPFLAGS __TEST_LDFLAGS __TEST_TMP
# Usage:
#   TEST "<test-cxxflags>" "<test-cppflags>" "<test-lddflags>" <tests...>
TEST() {
	__TEST_CCXFLAGS="$1"
	__TEST_CPPFLAGS="$2"
	__TEST_LDFLAGS="$3"
	shift 3
	__TEST_TMP=0
	for test_src in $@; do
		EXEC mkdir -p "$(dirname $OUT/$test_src.x)"
		EXEC $CCX -o "$OUT/$test_src.x" "$test_src" -Wno-unused-value $CCXFLAGS $__TEST_CCXFLAGS -I$TEST $CPPFLAGS $__TEST_CPPFLAGS $LDFLAGS $__TEST_LDFLAGS && \
			LD_LIBRARY_PATH="$OUT:$LIB:$LD_LIBRARY_PATH" "$OUT/$test_src.x"
		[ $? -ne 0 ] && __TEST_TMP=1
	done
	echo "Ran tests: $([ $__TEST_TMP -eq 0 ] && echo PASS || echo FAIL)"
}
EOF

# templating build
cat <<'EOF' > build
#!/bin/sh

. "$(dirname $0)/common.sh"

# target toolchain flags
COMMON_CCXFLAGS_EXT=""
COMMON_CPPFLAGS_EXT=""
COMMON_LDFLAGS_EXT=""

DBG_CCXFLAGS_EXT=""
DBG_CPPFLAGS_EXT=""
DBG_LDFLAGS_EXT=""

REL_CCXFLAGS_EXT=""
REL_CPPFLAGS_EXT=""
REL_LDFLAGS_EXT=""

CCXFLAGS_EXT="$COMMON_CCXFLAGS_EXT $(REGIME "CCXFLAGS_EXT")"
CPPFLAGS_EXT="$COMMON_CPPFLAGS_EXT $(REGIME "CPPFLAGS_EXT")"
LDFLAGS_EXT="$COMMON_LDFLAGS_EXT $(REGIME "LDFLAGS_EXT")"

[ $VERBOSE ] && echo "$TARGET CCXFLAGS: $CCXFLAGS_EXT"
[ $VERBOSE ] && echo "$TARGET CPPFLAGS: $CPPFLAGS_EXT"
[ $VERBOSE ] && echo "$TARGET LDFLAGS: $LDFLAGS_EXT"

SRCS="$SRC/main.c"
[ $VERBOSE ] && echo "Sources: $SRCS"

# compilation
EXECUTABLE $TARGET "$CCXFLAGS_EXT" "$CPPFLAGS_EXT" "$LDFLAGS_EXT" $SRCS

# testing
TESTS="$(find "$TEST" -name '*.c' -or -name '*.cpp')"
[ $VERBOSE ] && echo "Tests: $TESTS"

TEST "$CCXFLAGS_EXT" "$CPPFLAGS_EXT" "$LDFLAGS_EXT" $TESTS
EOF

# templating clean
cat <<'EOF' > clean
#!/bin/sh

. "$(dirname $0)/common.sh"

if [ $VERBOSE ]; then
	rm -frv $OBJ/* $OUT/*
else
	rm -fr $OBJ/* $OUT/*
fi
EOF

# templating .gitignore
cat <<'EOF' > .gitignore
obj/
out/

**/.*.swp
EOF

# initialise git repository
git init

# setting execute permissions
chmod +x build clean

# create wrapper Makefile
cat <<EOF > Makefile
.PHONY: clean debug memcheck release run threadcheck

MEMCHECK := valgrind --tool="memcheck" --leak-check=full --show-leak-kinds=all --track-origins=yes -s
THREADCHECK := valgrind --tool="helgrind" -s

run: debug
	./out/$PROJECT_NAME

debug: clean
	REGIME=DBG ./build

release: clean
	REGIME=REL ./build

clean:
	./clean

memcheck: debug
	\$(MEMCHECK) ./out/$PROJECT_NAME

threadcheck: debug
	\$(THREADCHECK) ./out/$PROJECT_NAME
EOF

# create editorconfig
cat <<'EOF' > .editorconfig
root = true

[*]
end_of_line = lf
insert_final_newline = true
charset = utf-8

[*.{c,cpp,h,hpp,tpp}]
indent_style = tab
indent_size = 8

[*.{sh,conf}]
indent_style = tab
indent_size = 8

[*.{css,html,js,jsx,ts,tsx}]
indent_style = space
indent_size = 2

[*.{json,md}]
indent_style = space
indent_size = 2
EOF

# create initial README.md
cat <<EOF > README.md
# $PROJECT_NAME

EOF

echo "Done!"
