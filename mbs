#!/bin/sh

##############################################################################
# MBS (Miko's Build System)
# ----------------------------------------------------------------------------
# This script sets up a simple, monorepo layout for building a single project
# or a suite of related projects (think LLVM repository structure). The actual
# build system is a set of dumb POSIX shell scripts that orchestrates building
# a set of top-level projects from scratch, with each project building its
# dependencies as required. Yes, this wastes some processor time on rebuilding
# objects and binaries that have already been compiled once. No, its never
# been an issue for me at the scale that I write toy software :)
# ----------------------------------------------------------------------------
# This script sets up a single C project, using the host toolchain, and a set
# of shell scripts that implement cleaning, building, and testing the single
# project. There is also a simple wrapper Makefile for convenience.
##############################################################################

set -e

SLUGIFY() {
	echo $1 | tr '[:blank:]' '-'
}

UPPERCASE() {
	echo $1 | tr '[:lower:]' '[:upper:]'
}

ELOG() {
	printf "%s\n" "$*" >&2
}

USAGE() {
	ELOG "Usage: $(basename $0) <project-name>"
	ELOG "  Creates a new monorepo-style project with the given name"
}

[ "${1:-z}" = "z" ] && ( USAGE; exit 1 )

ROOT="$(pwd)"
NAME="$(SLUGIFY $1)"
SLUG="$(UPPERCASE $NAME)"

if [ -d "$ROOT/$NAME" ]; then
	ELOG "Target folder $ROOT/$NAME already exists!";
	exit 1
fi

## template in repo and project layout

git init "$ROOT/$NAME"
cd "$ROOT/$NAME"

DIRS="
	$NAME $NAME/src $NAME/include $NAME/tests
	docs docs/$NAME
	include
"

mkdir $DIRS

## template in non-code files
cat >.editorconfig <<'EOF'
root = true

[*]
end_of_line = lf
insert_final_newline = true
charset = utf-8

[*.{c,cpp,h,hpp,tpp}]
indent_style = tab
indent_size = 8

[*.{sh}]
indent_style = tab
indent_size = 8

[*.{css,html,js,jsx,ts,tsx}]
indent_style = space
indent_size = 2

[*.{conf,json,md,txt}]
indent_style = space
indent_size = 2
EOF

cat >.gitignore <<'EOF'
bin/
lib/
obj/

**/.*.swp
EOF

cat >README.txt <<EOF
$NAME
==============================================================================
EOF

cat >docs/README.txt <<EOF
$NAME
==============================================================================
EOF

cat >docs/$NAME/README.txt <<EOF
$NAME
==============================================================================
EOF

touch LICENSE.txt

## template in common code files

cat >include/common.h <<'EOF'
#ifndef COMMON_H
#define COMMON_H

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <setjmp.h>
#include <stdalign.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdnoreturn.h>

typedef int32_t b32;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef float f32;
typedef double f64;

#define ALLOC_OVERFLOWS(type, count) ((UINT_MAX / sizeof(type)) < (count))
#define ARRLEN(arr) (sizeof(arr) / sizeof((arr)[0]))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

#define errlog(...) fprintf(stderr, __VA_ARGS__)

#ifndef NDEBUG
	#define dbglog(...) errlog(__VA_ARGS__)
#else
	#define dbglog(...)
#endif

#endif /* COMMON_H */
EOF

cat >include/test.h <<'EOF'
#ifndef TEST_H
#define TEST_H

#include "common.h"

#define TEST_PASS() return 1;
#define TEST_FAIL() return 0;

#define TEST(name, body)							\
s32										\
name(void) {									\
	s32 __##name##_result = 1; body; return __##name##_result;		\
}

#define TESTS_BEGIN() s32 __test_suite_result = 0;
#define TESTS_END() return __test_suite_result;

#define TEST_RUN(name)								\
{										\
	errlog("%s:%s:\n", __FILE__, #name);					\
	if (name()) {								\
		errlog("%s:%s: OK\n", __FILE__, #name);				\
	} else {								\
		errlog("%s:%s: FAILED\n", __FILE__, #name);			\
		__test_suite_result = 1;					\
	}									\
}

#define _TEST_ASSERT_IMPL(cond, msg)						\
errlog("[%s:%d] %s: %s\n", __func__, __LINE__, #cond, msg)

#define TEST_ASSERT(cond, msg)							\
if (!(cond)) { _TEST_ASSERT_IMPL(cond, msg); TEST_FAIL() }

#define TEST_EXPECT(cond, msg)							\
if (!(cond)) { _TEST_ASSERT_IMPL(cond, msg); }

#endif /* TEST_H */
EOF

## template in selected project

cat >$NAME/include/$NAME.h <<EOF
#ifndef ${SLUG}_H
#define ${SLUG}_H

#include "common.h"

#endif /* ${SLUG}_H */
EOF

cat >$NAME/src/$NAME.c <<EOF
#include "$NAME.h"

s32
main(s32 argc, char **argv) {
	(void)argc;
	(void)argv;

	dbglog("Version: " ${SLUG}_VERSION "\n");
	printf("Hello, World!\n");

	return 0;
}
EOF

cat >$NAME/src/unity.c <<EOF
#include "$NAME.c"
EOF

cat >$NAME/tests/test_$NAME.c <<EOF
#include "test.h"
#include "$NAME.h"

TEST(test_example, {
	int a = 42;

	TEST_EXPECT(a + 2 == 44, "a + 2 != 44")
	TEST_ASSERT(a == 42, "a != 42")

	TEST_PASS()
})

s32
main(s32 argc, char **argv) {
	(void)argc;
	(void)argv;

	TESTS_BEGIN()

	TEST_RUN(test_example)

	TESTS_END()
}
EOF

cat >$NAME/makefile.mk <<EOF
.PHONY: $NAME $NAME-build $NAME-deps $NAME-test

${SLUG}_MAJOR		:= 0
${SLUG}_MINOR		:= 1
${SLUG}_PATCH		:= 0
${SLUG}_VERSION		:= \$(${SLUG}_MAJOR).\$(${SLUG}_MINOR).\$(${SLUG}_PATCH)

${SLUG}_FLAGS		:= \\
			   \$(CFLAGS)						\\
			   \$(CPPFLAGS)						\\
			   -D${SLUG}_VERSION_MAJOR="\"\$(${SLUG}_MAJOR)"\"	\\
			   -D${SLUG}_VERSION_MINOR="\"\$(${SLUG}_MINOR)"\"	\\
			   -D${SLUG}_VERSION_PATCH="\"\$(${SLUG}_PATCH)"\"	\\
			   -D${SLUG}_VERSION="\"\$(${SLUG}_VERSION)"\"		\\
			   -I$NAME/include					\\
			   \$(LDFLAGS)

${SLUG}_TEST_FLAGS	:= \\
			   \$(CFLAGS)						\\
			   \$(CPPFLAGS)						\\
			   -I$NAME/include					\\
			   \$(LDFLAGS)

${SLUG}_SOURCES		:= $NAME/src/unity.c
${SLUG}_OBJECTS		:= \$(${SLUG}_SOURCES:%.c=\$(OBJ)/%.c.o)

${SLUG}_TEST_SOURCES	:= $NAME/tests/test_$NAME.c
${SLUG}_TEST_OBJECTS	:= \$(${SLUG}_TEST_SOURCES:%.c=\$(TST)/%.x)

\$(${SLUG}_OBJECTS): \$(OBJ)/%.c.o: %.c | \$(OBJ)
	@mkdir -p \$(shell dirname \$@)
	\$(CC) -o \$@ -c \$< \$(${SLUG}_FLAGS)

\$(${SLUG}_TEST_OBJECTS): \$(TST)/%.x: %.c | \$(TST)
	@mkdir -p \$(shell dirname \$@)
	\$(CC) -static -o \$@ \$< \$(${SLUG}_TEST_FLAGS)

\$(BIN)/$NAME: $NAME-deps \$(${SLUG}_OBJECTS) | \$(BIN)
	@mkdir -p \$(shell dirname \$@)
	\$(CC) -o \$@ \$(${SLUG}_OBJECTS) \$(${SLUG}_FLAGS)

$NAME-deps:

$NAME-build: \$(BIN)/$NAME

$NAME-test: \$(${SLUG}_TEST_OBJECTS)
	@for f in \$(${SLUG}_TEST_OBJECTS); do ./\$\$f ; done

$NAME: $NAME-build $NAME-test
EOF

cat >config.mk <<'EOF'
## toolchain
CC		?= cc
AR		?= ar
RANLIB		?= ranlib

STRIP		?= strip

TAR		?= tar
ZIP		?= gzip

## project build directories
BIN		:= bin
OBJ		:= obj
LIB		:= lib
TST		:= $(BIN)/tests

$(BIN):
	@mkdir -p $(BIN)

$(OBJ):
	@mkdir -p $(OBJ)

$(LIB):
	@mkdir -p $(LIB)

$(TST): $(BIN)
	@mkdir -p $(TST)

## project-wide includes
INC		:= include

## append project-wide toolchain flags
CFLAGS		:= $(CFLAGS) -std=c11 -Wall -Wextra -Wpedantic -Werror
CPPFLAGS	:= $(CPPFLAGS) -I$(INC)
LDFLAGS		:= $(LDFLAGS) -L$(LIB)

REGIME		?= DEBUG

DEBUG_CFLAGS	:= $(DEBUG_CFLAGS) -Og -ggdb
DEBUG_CPPFLAGS	:= $(DEBUG_CPPFLAGS) -UNDEBUG
DEBUG_LDFLAGS	:= $(DEBUG_LDFLAGS)

RELEASE_CFLAGS	:= $(RELEASE_CFLAGS) -O3 -flto
RELEASE_CPPFLAGS:= $(RELEASE_CPPFLAGS) -DNDEBUG
RELEASE_LDFLAGS	:= $(RELEASE_LDFLAGS) -flto

## append regime-specific toolchain flags
CFLAGS		:= $(CFLAGS) $($(REGIME)_CFLAGS)
CPPFLAGS	:= $(CPPFLAGS) $($(REGIME)_CPPFLAGS)
LDFLAGS		:= $(LDFLAGS) $($(REGIME)_LDFLAGS)
EOF

cat >Makefile <<EOF
.PHONY: all build clean test

all: build test

include config.mk

clean:
	rm -fr \$(BIN) \$(LIB) \$(OBJ)

build: $NAME-build

test: $NAME-test

include $NAME/makefile.mk
EOF

cd "$ROOT"
